# 03. 자바스크립트 데이터 타입과 연산자

## 기본 타입

1. 숫자
2. 문자열
3. 불린값
4. null
5. undefined

- typeof : 피연산자 타입을 리턴하는 연산자

- 자바스크립트는 느슨한 타입 체크 언어
  - 변수에 어떤 형태의 데이터를 저장하느냐에 따라 해당 변수의 타입이 결정

### Number (숫자)

- 모든 숫자를 64비트 부동 소수점 형태로 저장
- 정수형이 따로 없으므로 나눗셈 연산을 할 때 주의
  - 정수 부분만 구하려며 ```Math.floor()``` 함수를 사용

### 문자열

- 작은 따옴표```'```나 큰 따옴표```"```로 생성
- 한번 정의(생성)된 문자열은 읽기만 가능하고 변하지 않는다(수정 불가).
- 문자열은 문자배열처럼 인덱스로 접근가능
  
### 불린값 (Boolean)

- true와 false 값

### null과 undefined

- undefined : 값이 할당되지 않은 변수의 값이자 타입
- null : 개발자가 명시적으로 값이 비어있음을 나타내는 데 사용
  - null 타입 변수의 typeof 결과는 **Object**
    - 따라서 null타인인지 검사하기 위해서는 변수의 값을 직접 확인해야 한다.

---------------

## 참조 타입(객체 타입)

- 배열, 함수, 정규표현식 등 모두 객체로 표현
- 이름(key) : 값(value) 형태
  - Hash 자료구조와 유사
- 값을 함수를 포함할 수 있으며 이를 **메서드**라고 부른다.

### 객체 생성

#### 1. Object() 생성자 함수

```js
var foo = new Object();

foo.name = 'foo';
```

#### 2. 객체 리터럴 { } 

```js
var foo = {
  name : 'foo'
};
```

- "프로퍼티 이름" : 프로퍼티 값
- 프로퍼티 이름은 문자열이나 숫자가 올 수 있다.
- 프로퍼티 값이 함수일 경우 **메서드**라 부른다.

#### 3. 생성자 함수

- 함수를 통해 객체를 생성
- 자세한 건 [여기로](www.naver.com)


------

### 객체 프로퍼티 읽기/쓰기/갱신

#### 1. 대괄호([])

- 접근하려는 프로퍼티 이름을 **문자열**형태로 만들어야 한다.
  - 이름을 문자열 형태로 만들지 않으면 toString()을 통해서 이를 문자열로 바꾸려고 한다.
- 프로퍼티의 이름이 **표현식이거나 예약어일 경우** 대괄호 표기법을 사용해야 함

```js
foo["name"]
foo["full-name"]    //foo.full-name 시 정상적으로 작동안됨
```

#### 2. 마침표(.)

```js
foo.name
```

#### 값 할당 시

- 프로퍼티가 이미 있을 경우 : 값이 갱신
- 프로퍼티가 없을 경우 : 새로운 프로퍼티가 동적으로 생성된 후 값이 할당

```
NaN (Not a Number)

수치연산을 해서 정상적인 값을 얻어내지 못할 때 출력되는 값
```

#### for in 문

- 객체에 포함된 모든 프로퍼티에 대해 루프를 수행

```js
var foo = { name : 'foo', age : 30, major : 'computer' }
var prop;

for(prop in foo){
  console.log(prop, foo[prop]);
}
```

```
name foo
age 30
major computer
```

- prop에 키값(이름)이 할당

#### 프로퍼티 삭제

- ```delete``` 연산자를 사용
  - 단 이는 객체 자체는 삭제하지 못한다.

```js
delete foo.name
```

-----------

### 참조 타입의 특성

- 객체의 모든 연산이 실제 값이 아닌 참조값으로 처리되기 때문에 참조 타입이라 부른다.
- 즉, A 객체라 함은, 참조변수 A가 가리키고 있는 객체를 뜻한다.

#### 객체 비교

- 객체를 ```==```를 통해 비교할때 프로퍼티 값이 아닌 **참조값을 비교**한다.

#### Call By Reference

- 기본타입의 경우 Call By Value 방식
  - 함수를 호출할 때 기본 타입의 값을 넘기는 경우, 매개변수로 **복사된 값**이 전달
- 참조 타입의 경우 Call By Reference 방식
  - 인자로 넘긴 객체의 참조값이 그대로 함수 내부로 전달
  - 함수 내부에서 실제 객체의 값을 변경할 수 있다.
  
-----

## 프로토타입 (Prototype)

- 모든 객체는 자신의 부모 역할을 하는 객체(프로토타입 객체)와 연결되어 있다.
  - 상속의 개념
  - 부모 객체의 프로퍼티를 마치 자신의 것처럼 쓸 수 있다.

### ECMAScript는 [[Prototype]], 크롬은 __proto__가 프로토타입 객체를 가리키는 프로퍼티이다.
- 이 프로퍼티는 객체의 부모인 프로토타입 객체를 가리킨다.

- 모든 객체의 프로토타입은 객체를 생성할때 결정된다.
  - 객체를 생성하는 방식마다 결정되는 프로토타입이 다르다.
  - **객체 리터럴 방식**으로 생성할 경우 Object.prototype 객체가 프로토타입 객체가 된다.

- 프로토타입 객체는 임의의 다른 객체로 변경하는 것이 가능하다.
  - 즉 부모 객체를 동적으로 바꿀 수 있다. 이를 통해서 **상속**을 구현한다.

--------

## 배열

### 배열 리터럴 [  ]

```js
var arr1 = [1, 2, 3];

var arr2 = [];
arr[0] = 100;
arr[3] = 'eight';
arr[7] = true;
```

- 값을 순차적으로 넣을 필요 없이 아무 인덱스 위치에 값을 추가할 수 있다.
  - 값이 할당되지 않은 인덱스 요소는 undefined(empty) 값을 기본으로 가진다.

#### 배열의 크기(length)는 인덱스 중 가장 큰 값을 기준으로 정한다.

### length 프로퍼티

- 모든 배열은 length 프로퍼티가 있다.
- length 프로퍼티 = **배열 내 가장 큰 인덱스 값 + 1**
  - 즉, **length != 실제 배열에 존재하는 원소의 개수** 일수도 있다.
- 명시적으로 length 값을 변경할 수 있다.
  - length 값을 증가시킨 경우 : 할당되지 않은 인덱스는 undefined
  - length 값을 감소시킨 경우 : length 프로퍼티를 벗어나는 값은 삭제
- 배열 표준 메서드는 length 프로퍼티를 기반으로 동작한다.
  
### 배열도 객체다

- ```arr[0]```과 같이 [] 연산자를 통해서 인덱스에 접근할 때 숫자를 자동으로 문자열의 형태로 바꿔준다.
  - 왜냐하면 객체의 [] 접근은 문자열을 사용해야 하기 때문.
- typeof 결과는 ```Object```
- 배열의 프로토타입은 Array.prototype 객체
  - 여기에 배열 표준 메서드가 있다.
  - 또한 Array.prototype 객체의 프로토타입은 Object.prototype 객체이다.
  - 즉, 배열은 Array.prototype 객체와 Object.prototype 객체의 표준 메서드를 모두 사용할 수 있다.

### 배열에 프로퍼티 추가하기

```js
var arr = [0, 1, 2];
arr.color = 'blue';
arr.name = 'num_arr';
```

- 배열도 객체이므로 객체처럼 동적으로 프로퍼티 추가가 가능하다.
  - 단 이때 length 값이 바뀌지는 않는다.
  - 즉, length 프로퍼티는 가장 큰 인덱스가 변했을 경우만 변경된다.
- for in문을 사용하면 불필요한 프로퍼티가 출력될 수 있으므로 되도록 for문을 사용
  
### 배열 요소 삭제
- ```delete``` 연산자를 사용하면 해당 값이 undefined로 설정될 뿐 원소가 삭제되지 않는다.
- ```splice()```배열 매서드를 사용해야 한다.

```js
splice(start, deleteCount, item...)
// start - 시작위치
// deleteCount - 시작위치부터 삭제할 요소의 수
// item - 삭제할 위치에 추가할 요소

var arr = [0, 1, 2];
arr.splice(1, 1);
// arr => [0, 2]
```

### Array() 생성자 함수

```js
var foo1 = new Array();             // 빈 배열  []

var foo2 = new Array(3);            // length를 3으로 갖는 빈 배열
                                    // [undefined, undefined, undefined]

var foo3 = new Array(1, 2, 3);      // 인자를 요소로 갖는 배열
                                    // [1, 2, 3]
```

### 유사 배열 객체

- length 프로퍼티를 가진 일반 객체
- 일반적인 방법으론 표준 배열 메서드를 사용할 수 없다.
  - apply() 혹은 call() 함수를 사용하여 표준 배열 메서드를 사용할 수 있다.
  - 자세한 사항은 [call과 apply 메서드를 이용한 명시적인 this 바인딩](www.naver.com)를 참고

```js
Array.prototype.push.apply(obj, [el]);
```

- arguments 객체와 jQuery 객체가 유사 배열 객체이다.

-------

## 기본타입 표준 메서드

- 각 타입별로 호출 가능한 표준 메서드를 정의
  - 기본값은 메서드 처리 순간에 객체로 변환한 다음 각 타입별 표준 메서드를 호출
  - 메서드 호출이 끝나면 기본값으로 복귀

```js
var num = 0.5;
console.log(num.toExponential(1))   // 5.0e-1

console.log("test".charAt(2));      //s
```

- ```toExponential()``` : 숫자를 지수형태의 문자열로 변환
- ```charAt(n)``` : 문자열의 n번째 인덱스의 문자를 반환

-------

## 연산자

### +

1. 숫자에 쓰일 때 : 더하기 연산
2. 문자열에 쓰일 때 : 문자열 연결 연산

### typeof

- 피연산자의 타입을 문자열 형태로 리턴
- 단, 여기서 null은 Object, 함수는 function이다.

### == , ===

- ==(동등 연산자) : 타입변환을 거치고 비교
- ===(일치 연산자) : 타입을 고려하지 않고 바로 비교
  - 가급적 ```===```을 사용해야 한다.

### !!

- 피연산자를 불린값으로 변환
- 객체는 값이 비어있는 빈 객체라도 true로 변환

```js
!!0     // false
!!''    // false
!!{}    // true
```