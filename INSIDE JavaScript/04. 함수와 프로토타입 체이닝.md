# 함수와 프로토타입 체이닝

- 모듈화 처리
- 클로저
- 객체 생성

## 함수 정의

### 함수 리터럴
```js
function add(x, y){
	return x + y;
}
```

- 함수명은 선택사항
	- 이름이 없는 함수는 **익명함수**라고 한다

### 1. 함수 선언문
- 함수 리터럴과 동일한 형태
- 반드시 함수명이 정의되어 있어야 한다.
- 함수 선언문 형식으로 정의된 함수는 JS엔진에 의해 다음과 같은 함수 표현식 형태로 변경

```js
var add = function add(x, y){
	return x + y;
}
```

### 2. 함수 표현식
- 함수도 하나의 값처럼 취급(일급 객체)된다.
	- 함수도 숫자나 문자열처럼 변수에 할당하는 것이 가능하다.
- 함수 리터럴로 하나의 함수를 만들고 이 함수를 변수에 할당한다.

```js
var add = function(x, y){		// 익명함수 표현식
	return x+y;
}

var plus = add;			// plus는 add와 같은 함수를 참조
```

- 함수 이름은 선택사항이며 보통 사용하지 않는다.
	- 익명함수를 이용한 함수 표현식을 **익명함수 표현식** 이라고 한다.
	- 함수 이름이 포함된 함수 표현식을 **기명함수 표현식**이라고 한다.

```js
var add = fucntion sum(x, y){ 		// 기명 함수 표현식
	return x + y;
}
sum(3, 4);			// 에러
```

- 함수 표현식에서 사용된 함수 이름은 외부 코드에서 접근 할 수 없다.
	- 함수 이름으로 함수의 재귀적인 호출 처리가 가능하다.

```js
var factorialVar = function factorial(n){
	if(n<=1)		return 1;
	return n * factorial(n-1);		// 재귀호출
```


> #### 세미콜론
>
>> - 함수선언문 방식으로 선언된 함수의 경우 끝에 세미콜론(```;```)을 붙이지 않는다.
>> - 함수표현식 방식의 경우는 세미콜론(```;```)을 붙이는 것을 권장

>>> ```js
	var func = function(){
		return 42;
	}				// 세미콜론을 사용하지 않음
	(function(){
		console.log(“f”);
	})();
	```
>> - func의 중괄호 후 ()가 나오니 이를 호출한다.(괄호 안의 함수가 인자로 전달된다고 생각)
>> - 따라서 func가 반환된 후 ```42()``` 형태가 되어 버리고 다시 함수를 호출하려 한다.
>> - 따라서 에러가 발생하게 된다.

>>> - 이런 문제가 발생할 수 있기에 함수 표현식 방식에서의 세미콜론 사용을 강력하게 권고한다.


### 3. Function() 생성자 함수

- 함수 역시 Function()이라는 기본 내장 생성자로부터 생성된 객체
	- 내부적으로는 Function() 생성자 함수로 함수가 생성된다.

```js
new Function(arg1, arg2, ... , argN, functionBody)
```

***

### 함수 호이스팅

- 함수가 자신이 위치한 코드에 상관없이 함수 선언문 형태로 정의한 함수의 유효범위는 코드의 맨 처음부터 시작한다.
	- 이는 함수 사용 이후 선언이 나오는 것을 허락하기 때문에 구조를 엉성하게 만든다.

```js
add(2, 3);				//선언 안되어 있지만 함수 호이스팅으로 인해 호출 가능

function add(x, y){
	return x + y;
}
```

- 함수 호이스팅으로 인해, 함수 표현식만을 사용할 것을 권장한다.
- 함수 호이스팅은 변수 생성과 초기화의 작업이 분리되어 진행되기 때문이다. 자세한 것은 [여기로](www.naver.com)

***

## 함수 객체 (일급 객체)

- 함수 자체도 일반 객체처럼 프로퍼티를 가질 수 있다.
	- 함수 코드는 함수 객체의 **[[Code]]** 내부 프로퍼티에 자동으로 저장

- 함수는 일반 객체처럼 값으로 취급될 수 있다.
	- 변수나 객체, 배열에 값으로 저장 가능
	- 인자로 전달하거나 리턴값으로 사용가능

### 함수 객체의 기본 프로퍼티

- 모든 함수는 length와 prototype 프로퍼티를 가져야 한다. (ECMAScript 명세)
- `name` 프로퍼티 : 함수의 이름, 익명함수의 경우 빈 문자열
- `caller` 프로퍼티 : 자신을 호출한 함수
- `arguments` 프로퍼티 : 함수르 호출할 때 전달된 인자 값

- 	```
	arguments 객체
	
	함수를 호출할 때 호출된 함수의 내부로 인자값과 함께 전달되며, arguments 프로퍼티와 유사하게 함수를 호출 할 때 전달 인자값의 정보를 제공해 준다.
	```
	자세한 건 [여기로](www.naver.com)
	
- `__proto__` : `[[Prototype]]`과 같은 개념. 객체의 부모 객체
	- 함수의 경우 `Function.prototype` 객체. 이 역시 함수 객체이다. 이는 모든 함수의 부모역할을 한다.
		- `Function.prototype`의 부모는 `Object.prototype`이다.
	- constructor 프로퍼티, toString() 메서드, apply, call, bind 메서드를 가진다.
- `length` : 함수가 정상적으로 실행될 때 기대되는 인자의 개수. 즉 함수를 작성할때 정의한 인자의 개수

#### Prototype 프로퍼티

- 모든 함수는 `prototype` 프로퍼티를 가진다.
- `prototype` 프로퍼티는 [[Prototype]] 프로퍼티(`__proto__`)와는 다르다.
	- 두 프로퍼티 모두 **프로토타입 객체**를 가르킨다.
		1. **[[Prototype]](`__proto__`)**은 객체 입장에서 자신의 부모역할을 하는 프로토타입 객체를 가리키지만.
		2. **prototype**은 이 함수가 생성자로 사용될 때, 이 함수를 통해 생성된 객체의 부모 역할을 하는 프로토타입 객체를 가리킨다.
- 함수가 생성될 때 만들어지며, constructor 프로퍼티 하나만 있는 객체(프로토타입 객체)를 가리킨다.
	- constructor 프로퍼티는 자신과 연결된 함수를 가리킨다.
	- 이 또한 객체이기 때문에 `__proto__` 프로퍼티 역시 가지고 있다.
##### 즉 함수가 생성될 때 1. 함수 자신과 연결된 프로토타입 객체를 동시에 생성 2. 이 둘은 각각 prototype, constructor 프로퍼티로 서로를 가르킨다.(참조한다.)

***

## 함수의 다양한 형태

### 1. 콜백 함수 callback function
- 익명함수의 대표적인 용도
- 개발자가 등록해 놓으면, 특정 이벤트나 시점에 도달했을 때 시스템에서 호출되는 함수
- 특정 함수의 인자로 넘겨서 코드 내부에서 호출되는 함수

```js
window.onload = function(){
	alert(‘callback’);
};
```

### 2. 즉시 실행 함수 immediate function
- 함수의 정의와 동시에 바로 실행되는 함수
- 함수 리터럴을 괄호로 둘러싼 후 함수가 바로 호출될 수 있게 괄호 쌍을 추가한다.
	- 이름은 있든 없든 상관없다.
	- 두번째 괄호안에 값을 넣어 인자를 전달할 수 있다.
```js
(function (name){
	console.log(name);
})(‘foo’);
```

- 같은 함수를 다시 호출할 수 없다.
	- 최초 한번의 실행만을 필요로 하는 초기화 코드 부분에 사용된다.

- 함수 유효 범위(함수 스코프)를 지원
	- 함수 내부에서 정의된 변수들은 함수 내부에서만 유효 (이때 var 를 사용하지 않으면, 전역 유효범위를 가지니 조심)
	- 따라서 즉시실행 함수 내부에 라이브러리 코드를 작성하면 외부에서 라이브러리의 변수에 접근할 수 없다.

### 3. 내부함수

- 함수 코드 내부에서 다시 정의한 함수
- 클로저를 생성하거나 외부에서의 접근을 막고 독립적인 헬퍼 함수를 구현


1. 내부 함수에서는 자신을 둘러싼 부모 함수의 변수에 접근이 가능.
	- 이것이 가능한 이유는 **스코프 체이닝** 덕분
2. 내부함수는 자신이 정의된 부모함수 내부에서만 호출이 가능하다.
	- 함수 스코핑 때문
	- 함수 내부에 선언된 변수는 함수 외부에서 잡근이 불가능
3. 단 내부함수를 리턴하는 경우, 부모 함수 밖에서도 내부 함수를 호출하는 것이 가능하다.
```js
function parent(){
	var a = 100;
	var child = function(){
		console.log(a);
	}
	return child;
}

var inner = parent();
inner();
```
- inner가 내부 함수인 child() 함수를 참조하게 된다.
	- 이와 같이 실행이 끝난 부모 함수 스코프의 변수를 참조하는 inner 같은 함수를 **클로저**라고 한다.

### 4. 함수를 리턴하는 함수
	
- 일반 값처럼 함수를 리턴
	- 함수 호출과 동시에 다른 함수로 바꾸는 하무
	- 자기 자신을 재정의 하는 함수

```js
var self = function(){
	console.log(‘a’);
	return function(){
		console.log(‘b’);
	}
}
self = self();				//a
self();							//b
```

***


## arguments 객체

- 함수 호출시 함수 형식에 맞추지 않고 인자를 넘겨도 에러가 발생하지 않는다.
	- 넘겨지지 않은 인자는 undefined 값이 할당
	- 초과된 인수는 무시된다.

- 함수 호출시 인자들이 전달 될 때 arguments 객체도 같이 전달된다.
	- arguments 객체는 함수를 호출할 때 넘긴 인자들이 저장되어 있는 **유사 배열 객체**

#### arguments 객체의 구성

1. 넘겨진 인자 (배열 형태)
2. length 프로퍼티 : 호출할때 넘겨진 인자의 개수
3. callee 프로퍼티 : 현재 실행중인 함수의 참조값

- length가 있지만 배열이 아니므로 배열 메서드를 사용할 경우 에러

- 런타임시 호출된 인자의 개수를 확인하고 이에 따라 동작을 다르게 해줘야 할 경우 사용
	- 매개변수가 정확하게 정해지지 않은 함수 구현
	- 전달된 인자의 개수에 따라 서로 다른처리를 해줘야 하는 함수를 구현

```js
function sum(){
	var result = 0;
	for(var i=0; i<arguments.length; i++)
		result += arguments[i];
	return result;
}

sum(1,2,3);
sum(1,2,4,6,7,8);
```

***

## this 바인딩

- 함수 호출시 인자값과 arguments 객체, 그리고 this 인자가 전달된다.
- this의 경우 호출 패턴에 따라서 각기 다른 객체에 바인딩 된다.

### 1. 객체의 매서드 호출시

- this는 해당 메서드를 호출한 객체로 바인딩
	- 즉 자신을 호출한 객체에 바인딩

### 2. 일반 함수 호출시

- this는 전역 객체에 바인딩
	- 브라우저는 window, Node는 global 객체
	- 모든 전역변수는 전역 객체의 프로퍼티

#### 내부 함수를 호출 했을 때도 this는 전역 객체에 바인딩 된다.
- 객체의 메서드를 호출하였을 때 이 메서드에서의 this는 호출한 객체이지만 이 메서드의 내부 함수에서의 this는 전역 객체이다.

```js
var value = 100;

var myObject = {
	value : 1,
	func1 : function(){
		this.value += 1;				// this는 myObject(메서드를 부른 객체)
		func2 = function(){
			this.value += 1;			// this는 전역 객체
		}
		func2();
	}
};
myObject.func1();
```
- 이러한 문제점을 해결하기 위해 부모함수의 this를 내부 함수가 접근 가능한 다른 변수에 저장
	- this 값을 저장하는 변수를 보통 **that**으로 짓는다.

```js
var value = 100;

var myObject = {
	value : 1,
	func1 : function(){
		var that = this;				// this값을 that에 저장
		
		this.value += 1;				// this는 myObject(메서드를 부른 객체)
		func2 = function(){
			that.value += 1;			// that을 사용
		}
		func2();
	}
};
myObject.func1();
```


### 3. 생성자 함수 호출시

- 기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작
	- 생성자 함수는 첫 문자를 대문자로 쓰기를 권고
- this는 생성자 함수가 새로 생성한 빈 객체가 된다.

#### 생성자 함수가 동작하는 방식

1. 빈 객체 생성 및 this 바인딩
	- 함수 코드가 실행되기 전 빈 객체가 생성된다.
		- 이 객체가 생성자 함수가 새로 생성하는 객체
		- 해당 객체가 this로 바인딩 된다.
	- 생성자 함수가 생성한 객체는 [생성자 함수의 prototype 프로퍼티가 가리키는 객체](`함수명.prototype`)를 자신의 프로토타입 객체(`[[Prototype]]`)로 설정
2. this를 통한 프로퍼티 생성
3. 생성된 객체 리턴
	- 특별한 리턴문이 없으면 this로 바인딩 된 새로 생성된 객체가 리턴
	- 단 이때, 일반 함수 호출을 한 경우 리턴값이 없으면 undefined가 리턴되므로 주의

#### 객체 리터럴 방식 vs 생성자 함수 방식

|  | [[Prototype]] | 실제 [[Prototype]] | 생성자 함수 |
|:--:|:--:|:--:|:--:|
| 객체 리터럴 방식 | Object | Object.prototype | Object() |
| 생성자 함수 방식 | 함수명 | 함수명.prototype<br>(즉, 생성자 함수의 prototype이 가리키는 객체) | 생성자 함수 그 자체 |

##### new를 붙이지 않고 호출한 경우 this의 바인딩 방식이 다르기 때문에 오류가 발생할 수도 있다.
1. 일반 함수 호출 : this는 window 전역 객체(Node의 경우 global)에 바인딩
2. 생성자 함수 호출 : this는 새로 생성되는 빈 객체에 바인딩

#### instanceof
```js
function A(arg){
	if(!(this instanceof A))
		return new A(arg);
	this.value = arg ? arg : 0;
}
```
- `instanceof`를 사용하여 this가 A의 인스턴스인지 확인한다.
	- this가 A의 인스턴스가 아니라면, new로 호출된것이 아님을 의미
	- 따라서 `new A(arg)`로 다시 호출해 준다.
- `if(!(this instansof arguments.callee))`를 쓰면 함수 이름과 상관없이 작동하도록 할 수 있다.


### 4. call과 apply 메서드를 이용한 명시적 바인딩

- this를 특정 객체에 명시적으로 바인딩 시키는 함수
- 


***

## 함수 리턴

1. 일반 함수나 메서드는 리턴값을 지정하지 않을 경우 undefined 값이 리턴
2. 생성자 함수에서 리턴값을 지정하지 않을 경우 생성된 객체가 리턴
	- 생성자 함수에서 다른객체를 반환할 경우 다른객체가 그대로 반환됨

